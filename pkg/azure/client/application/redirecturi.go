package application

import (
	v1 "github.com/nais/liberator/pkg/apis/nais.io/v1"
	msgraph "github.com/nais/msgraph.go/v1.0"

	"github.com/nais/azureator/pkg/azure"
	"github.com/nais/azureator/pkg/azure/transaction"
	"github.com/nais/azureator/pkg/azure/util"
)

// Workaround to include empty array of RedirectUris in JSON serialization.
// The autogenerated library code uses 'omitempty' for RedirectUris, which when empty
// leaves the list of redirect URIs unchanged and non-empty and is thus considered unmodified in the PATCH operation.
type emptiableRedirectUris struct {
	RedirectUris []string `json:"redirectUris"`
}

type redirectUri struct {
	azure.Application
}

func newRedirectUri(application azure.Application) azure.RedirectUri {
	return redirectUri{Application: application}
}

func (r redirectUri) Update(tx transaction.Transaction) error {
	objectId := tx.Instance.GetObjectId()
	app := RedirectUriApp(tx.Instance)

	return r.Application.Patch(tx.Ctx, objectId, app)
}

func RedirectUriApp(instance v1.AzureAdApplication) interface{} {
	redirectUris := util.GetReplyUrlsStringSlice(instance)

	if instance.Spec.SinglePageApplication != nil && *instance.Spec.SinglePageApplication {
		return singlePageApp(redirectUris)
	}
	return webApp(redirectUris)
}

func webApp(redirectUris []string) interface{} {
	return &struct {
		msgraph.DirectoryObject
		Web emptiableRedirectUris `json:"web"`
		Spa emptiableRedirectUris `json:"spa"`
	}{
		Web: emptiableRedirectUris{
			RedirectUris: redirectUris,
		},
		Spa: emptiableRedirectUris{
			RedirectUris: make([]string, 0),
		},
	}
}

func singlePageApp(redirectUris []string) interface{} {
	return &struct {
		msgraph.DirectoryObject
		Web emptiableRedirectUris `json:"web"`
		Spa emptiableRedirectUris `json:"spa"`
	}{
		Web: emptiableRedirectUris{
			RedirectUris: make([]string, 0),
		},
		Spa: emptiableRedirectUris{
			RedirectUris: redirectUris,
		},
	}
}
