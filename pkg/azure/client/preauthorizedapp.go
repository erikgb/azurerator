package client

import (
	"context"
	"fmt"
	"github.com/nais/liberator/pkg/kubernetes"
	msgraphbeta "github.com/yaegashi/msgraph.go/beta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/nais/azureator/pkg/azure"
	"github.com/nais/azureator/pkg/azure/util"
	v1 "github.com/nais/liberator/pkg/apis/nais.io/v1"
	msgraph "github.com/yaegashi/msgraph.go/v1.0"
)

// Workaround to include empty array of PreAuthorizedApplications in JSON serialization.
// The autogenerated library code uses 'omitempty' for preAuthorizedApplications.
// If all the pre-authorized applications are removed from our custom resource, the PATCH operation on the Azure
// 'Application' resource will not update the list of pre-authorized applications in Azure AD,
// which will no longer reflect our observed nor desired cluster state.
type preAuthAppPatch struct {
	PreAuthorizedApplications []msgraph.PreAuthorizedApplication `json:"preAuthorizedApplications"`
}

type appPatch struct {
	msgraph.DirectoryObject
	API preAuthAppPatch `json:"api"`
}

type preAuthApps struct {
	client
}

func (c client) preAuthApps() preAuthApps {
	return preAuthApps{c}
}

func (p preAuthApps) process(tx azure.Transaction) ([]azure.Resource, error) {
	servicePrincipalId := tx.Instance.GetServicePrincipalId()

	preAuthApps, err := p.patchApplication(tx)
	if err != nil {
		return nil, fmt.Errorf("updating preauthorizedapps for application: %w", err)
	}

	resources, err := p.mapToResources(tx.Ctx, preAuthApps)
	if err != nil {
		return nil, fmt.Errorf("mapping preauthorizedapps to resources: %w", err)
	}

	err = p.appRoleAssignments(msgraphbeta.UUID(DefaultAppRoleId), servicePrincipalId).
		processForServicePrincipals(tx, resources)
	if err != nil {
		return nil, fmt.Errorf("updating approle assignments for service principals: %w", err)
	}
	return resources, nil
}

func (p preAuthApps) patchApplication(tx azure.Transaction) ([]msgraph.PreAuthorizedApplication, error) {
	objectId := tx.Instance.GetObjectId()

	preAuthApps, err := p.toGraphRequest(tx)
	if err != nil {
		return nil, err
	}

	app := appPatch{API: preAuthAppPatch{PreAuthorizedApplications: preAuthApps}}
	if err := p.application().patch(tx.Ctx, objectId, app); err != nil {
		return nil, fmt.Errorf("patching preauthorizedapps for application: %w", err)
	}
	return preAuthApps, nil
}

func (p preAuthApps) exists(ctx context.Context, app v1.AccessPolicyRule) (bool, error) {
	return p.application().existsByFilter(ctx, util.FilterByName(p.getUniqueName(app)))
}

func (p preAuthApps) toGraphRequest(tx azure.Transaction) ([]msgraph.PreAuthorizedApplication, error) {
	apps := make([]msgraph.PreAuthorizedApplication, 0)
	for _, app := range tx.Instance.Spec.PreAuthorizedApplications {

		if len(app.Cluster) == 0 {
			app.Cluster = tx.Instance.GetClusterName()
		}

		if len(app.Namespace) == 0 {
			app.Namespace = tx.Instance.GetNamespace()
		}

		exists, err := p.exists(tx.Ctx, app)
		if err != nil {
			return nil, fmt.Errorf("looking up existence of PreAuthorizedApp '%s': %w", p.getUniqueName(app), err)
		}

		if !exists {
			tx.Log.Debugf("skipping PreAuthorizedApp assignment: '%s' does not exist", p.getUniqueName(app))
			continue
		}

		clientId, err := p.getClientIdFor(tx.Ctx, app)
		if err != nil {
			return nil, err
		}

		apps = append(apps, msgraph.PreAuthorizedApplication{
			AppID:                  &clientId,
			DelegatedPermissionIDs: []string{OAuth2DefaultPermissionScopeId},
		})
	}
	return apps, nil
}

func (p preAuthApps) mapToResources(ctx context.Context, preAuthApps []msgraph.PreAuthorizedApplication) ([]azure.Resource, error) {
	resources := make([]azure.Resource, 0)
	for _, preAuthApp := range preAuthApps {
		app, err := p.application().getByClientId(ctx, *preAuthApp.AppID)
		if err != nil {
			return nil, fmt.Errorf("mapping to preauthorized apps to resources: looking up application: %w", err)
		}

		spExists, sp, err := p.servicePrincipal().exists(ctx, *preAuthApp.AppID)
		if err != nil {
			return nil, fmt.Errorf("mapping to preauthorized apps to resources: looking up service principal: %w", err)
		}
		if !spExists {
			continue
		}

		resources = append(resources, azure.Resource{
			Name:          *app.DisplayName,
			ClientId:      *preAuthApp.AppID,
			ObjectId:      *sp.ID,
			PrincipalType: azure.PrincipalTypeServicePrincipal,
		})
	}
	return resources, nil
}

func (p preAuthApps) getClientIdFor(ctx context.Context, app v1.AccessPolicyRule) (azure.ClientId, error) {
	azureApp, err := p.application().getByName(ctx, p.getUniqueName(app))
	if err != nil {
		return "", fmt.Errorf("failed to get client ID for preauthorized app: %w", err)
	}
	return *azureApp.AppID, nil
}

func (p preAuthApps) getUniqueName(in v1.AccessPolicyRule) string {
	return kubernetes.UniformResourceName(&metav1.ObjectMeta{
		Name:        in.Application,
		Namespace:   in.Namespace,
		ClusterName: in.Cluster,
	})
}
