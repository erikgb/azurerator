package client

import (
	"context"
	"fmt"

	"github.com/nais/azureator/api/v1"
	"github.com/nais/azureator/pkg/azure"
	"github.com/nais/azureator/pkg/azure/util"
	msgraph "github.com/yaegashi/msgraph.go/v1.0"
)

// Workaround to include empty array of PreAuthorizedApplications in JSON serialization.
// The autogenerated library code uses 'omitempty' for preAuthorizedApplications.
// If all the pre-authorized applications are removed from our custom resource, the PATCH operation on the Azure
// 'Application' resource will not update the list of pre-authorized applications in Azure AD,
// which will no longer reflect our observed nor desired cluster state.
type preAuthAppApi struct {
	PreAuthorizedApplications []msgraph.PreAuthorizedApplication `json:"preAuthorizedApplications"`
}

type preAuthApps struct {
	client
}

func (c client) preAuthApps() preAuthApps {
	return preAuthApps{c}
}

func (p preAuthApps) update(tx azure.Transaction) ([]azure.PreAuthorizedApp, error) {
	objectId := tx.Instance.Status.ObjectId
	preAuthApps, err := p.mapToMsGraph(tx)
	if err != nil {
		return nil, err
	}
	app := &struct {
		msgraph.DirectoryObject
		API preAuthAppApi `json:"api"`
	}{API: preAuthAppApi{PreAuthorizedApplications: preAuthApps}}
	appReq := p.graphClient.Applications().ID(objectId).Request()
	if err := appReq.JSONRequest(tx.Ctx, "PATCH", "", app, nil); err != nil {
		return nil, fmt.Errorf("failed to update PreAuthorizedApps in azure: %w", err)
	}
	return p.mapWithNames(tx.Ctx, preAuthApps)
}

func (p preAuthApps) exists(ctx context.Context, app v1.AzureAdPreAuthorizedApplication) (bool, error) {
	return p.application().existsByFilter(ctx, util.FilterByName(app.GetUniqueName()))
}

func (p preAuthApps) mapToMsGraph(tx azure.Transaction) ([]msgraph.PreAuthorizedApplication, error) {
	apps := make([]msgraph.PreAuthorizedApplication, 0)
	for _, app := range tx.Instance.Spec.PreAuthorizedApplications {
		exists, err := p.exists(tx.Ctx, app)
		if err != nil {
			return nil, fmt.Errorf("failed to lookup existence of PreAuthorizedApp '%s': %w", app.GetUniqueName(), err)
		}
		if !exists {
			tx.Log.Debugf("PreAuthorizedApp '%s' does not exist, skipping assignment...", app.GetUniqueName())
			continue
		}
		a, err := p.toMsGraph(tx, app)
		if err != nil {
			return nil, err
		}
		apps = append(apps, a)
	}
	return apps, nil
}

func (p preAuthApps) toMsGraph(tx azure.Transaction, app v1.AzureAdPreAuthorizedApplication) (msgraph.PreAuthorizedApplication, error) {
	clientId, err := p.getClientIdFor(tx.Ctx, app)
	if err != nil {
		return msgraph.PreAuthorizedApplication{}, err
	}
	return msgraph.PreAuthorizedApplication{
		AppID:                  &clientId,
		DelegatedPermissionIDs: []string{OAuth2DefaultPermissionScopeId},
	}, nil
}

func (p preAuthApps) mapWithNames(ctx context.Context, preAuthApps []msgraph.PreAuthorizedApplication) ([]azure.PreAuthorizedApp, error) {
	a := make([]azure.PreAuthorizedApp, 0)
	for _, preAuthApp := range preAuthApps {
		app, err := p.application().getByClientId(ctx, *preAuthApp.AppID)
		if err != nil {
			return nil, fmt.Errorf("failed to map preauthorized apps with names: %w", err)
		}
		a = append(a, azure.PreAuthorizedApp{
			Name:     *app.DisplayName,
			ClientId: *preAuthApp.AppID,
		})
	}
	return a, nil
}

func (p preAuthApps) getClientIdFor(ctx context.Context, app v1.AzureAdPreAuthorizedApplication) (azure.ClientId, error) {
	azureApp, err := p.application().getByName(ctx, app.GetUniqueName())
	if err != nil {
		return "", fmt.Errorf("failed to get client ID for preauthorized app: %w", err)
	}
	return *azureApp.AppID, nil
}
