package client

import (
	"context"
	"fmt"

	v1 "github.com/nais/liberator/pkg/apis/nais.io/v1"
	"github.com/nais/liberator/pkg/kubernetes"
	msgraph "github.com/nais/msgraph.go/v1.0"

	"github.com/nais/azureator/pkg/azure"
	"github.com/nais/azureator/pkg/azure/util"
	"github.com/nais/azureator/pkg/customresources"
)

// Workaround to include empty array of PreAuthorizedApplications in JSON serialization.
// The autogenerated library code uses 'omitempty' for preAuthorizedApplications.
// If all the pre-authorized applications are removed from our custom resource, the PATCH operation on the Azure
// 'Application' resource will not update the list of pre-authorized applications in Azure AD,
// which will no longer reflect our observed nor desired cluster state.
type preAuthAppPatch struct {
	PreAuthorizedApplications []msgraph.PreAuthorizedApplication `json:"preAuthorizedApplications"`
}

type appPatch struct {
	msgraph.DirectoryObject
	API preAuthAppPatch `json:"api"`
}

type preAuthApps struct {
	client
}

func (c client) preAuthApps() preAuthApps {
	return preAuthApps{c}
}

func (p preAuthApps) process(tx azure.Transaction) (*azure.PreAuthorizedApps, error) {
	servicePrincipalId := tx.Instance.GetServicePrincipalId()

	preAuthorizedApps, err := p.mapToResources(tx)
	if err != nil {
		return nil, fmt.Errorf("mapping preauthorizedapps to resources: %w", err)
	}

	err = p.patchApplication(tx, preAuthorizedApps.Valid)
	if err != nil {
		return nil, fmt.Errorf("updating preauthorizedapps for application: %w", err)
	}

	defaultRole := p.application().appRoles().defaultRole()
	roleID, err := p.application().appRoles().getOrGenerateRoleID(tx, defaultRole)
	if err != nil {
		return nil, fmt.Errorf("fetching default app role ID: %w", err)
	}

	err = p.appRoleAssignments(*roleID, servicePrincipalId).
		processForServicePrincipals(tx, preAuthorizedApps.Valid)
	if err != nil {
		return nil, fmt.Errorf("updating approle assignments for service principals: %w", err)
	}
	return preAuthorizedApps, nil
}

func (p preAuthApps) patchApplication(tx azure.Transaction, resources []azure.Resource) error {
	objectId := tx.Instance.GetObjectId()
	payload := p.mapToGraphRequest(resources)

	if err := p.application().patch(tx.Ctx, objectId, payload); err != nil {
		return fmt.Errorf("patching preauthorizedapps for application: %w", err)
	}

	return nil
}

func (p preAuthApps) exists(ctx context.Context, app v1.AccessPolicyRule) (*msgraph.Application, bool, error) {
	return p.application().existsByFilter(ctx, util.FilterByName(customresources.GetUniqueName(app)))
}

func (p preAuthApps) mapToResources(tx azure.Transaction) (*azure.PreAuthorizedApps, error) {
	seen := make(map[string]bool)

	validResources := make([]azure.Resource, 0)
	invalidResources := make([]azure.Resource, 0)

	for _, app := range tx.Instance.Spec.PreAuthorizedApplications {
		app = ensureFieldsAreSet(tx, app)

		resource, exists, err := p.mapToResource(tx, app)
		if err != nil {
			return nil, fmt.Errorf("looking up existence of PreAuthorizedApp '%s': %w", customresources.GetUniqueName(app), err)
		}

		if !exists {
			invalidResources = append(invalidResources, *resource)
			continue
		}

		if !seen[resource.Name] {
			seen[resource.Name] = true
			validResources = append(validResources, *resource)
		}
	}

	if !seen[kubernetes.UniformResourceName(&tx.Instance)] {
		validResources = append(validResources, toResource(tx.Instance))
	}

	return &azure.PreAuthorizedApps{
		Valid:   validResources,
		Invalid: invalidResources,
	}, nil
}

func (p preAuthApps) mapToGraphRequest(resources []azure.Resource) appPatch {
	apps := make([]msgraph.PreAuthorizedApplication, 0)
	for _, resource := range resources {
		clientId := resource.ClientId

		apps = append(apps, msgraph.PreAuthorizedApplication{
			AppID:                  &clientId,
			DelegatedPermissionIDs: []string{OAuth2DefaultPermissionScopeId},
		})
	}

	return appPatch{API: preAuthAppPatch{PreAuthorizedApplications: apps}}
}

func (p preAuthApps) mapToResource(tx azure.Transaction, app v1.AccessPolicyRule) (*azure.Resource, bool, error) {
	application, exists, err := p.exists(tx.Ctx, app)
	if err != nil || !exists {
		return invalidResource(app), false, err
	}

	exists, servicePrincipal, err := p.servicePrincipal().exists(tx.Ctx, *application.AppID)
	if err != nil || !exists {
		return invalidResource(app), false, err
	}

	return &azure.Resource{
		Name:          *application.DisplayName,
		ClientId:      *application.AppID,
		ObjectId:      *servicePrincipal.ID,
		PrincipalType: azure.PrincipalTypeServicePrincipal,
	}, true, nil
}

func invalidResource(app v1.AccessPolicyRule) *azure.Resource {
	return &azure.Resource{
		Name:          customresources.GetUniqueName(app),
		ClientId:      "",
		ObjectId:      "",
		PrincipalType: azure.PrincipalTypeServicePrincipal,
	}
}

func toResource(instance v1.AzureAdApplication) azure.Resource {
	return azure.Resource{
		Name:          kubernetes.UniformResourceName(&instance),
		ClientId:      instance.Status.ClientId,
		ObjectId:      instance.Status.ServicePrincipalId,
		PrincipalType: azure.PrincipalTypeServicePrincipal,
	}
}

func ensureFieldsAreSet(tx azure.Transaction, rule v1.AccessPolicyRule) v1.AccessPolicyRule {
	if len(rule.Cluster) == 0 {
		rule.Cluster = tx.Instance.GetClusterName()
	}

	if len(rule.Namespace) == 0 {
		rule.Namespace = tx.Instance.GetNamespace()
	}

	return rule
}
